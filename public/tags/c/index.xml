<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C on Daker Pinheiro</title>
    <link>https://dakerfp.com/tags/c/</link>
    <description>Recent content in C on Daker Pinheiro</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>â’¸ 2017 Daker Fernandes Pinheiro</copyright>
    <lastBuildDate>Fri, 27 Dec 2013 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://dakerfp.com/tags/c/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Improve your lazy debugging in C&#43;&#43;</title>
      <link>https://dakerfp.com/post/improve-your-lazy-debugging-in-c/</link>
      <pubDate>Fri, 27 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>https://dakerfp.com/post/improve-your-lazy-debugging-in-c/</guid>
      <description>Are you too lazy to learn your debugger? When debugging, I usually want to know if some code section is reached.
I can do this:
void foobar() { printf(&amp;quot;foobar()\n&amp;quot;); // ... do foobar }  But I should use cout instead printf in C++. printf is faster, but in this case it should be irrelevant. So I have:
void foobar() { std::cout &amp;lt;&amp;lt; &amp;quot;foobar()&amp;quot; &amp;lt;&amp;lt; std::endl; // ... do foobar }  I could also use GCC&amp;rsquo;s function name macro __PRETTY_FUNCTION__ and __LINE__ macro to identify the reached code section easier.</description>
    </item>
    
    <item>
      <title>How to set a X window visible or invisible using Xlib</title>
      <link>https://dakerfp.com/post/how-to-set-x-window-visible-or-invisible/</link>
      <pubDate>Thu, 19 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>https://dakerfp.com/post/how-to-set-x-window-visible-or-invisible/</guid>
      <description>bool m_visible; Display* m_display; Window m_window; void setVisible(bool visible) { if (visible == m_visible) return; if (visible) XMapWindow(m_display, m_window); else XUnmapWindow(m_display, m_window); m_visible = visible; }  </description>
    </item>
    
    <item>
      <title>OpenGL Lesson 02 - Drawing with OpenGL</title>
      <link>https://dakerfp.com/post/opengl-lesson-02-drawing-with-opengl/</link>
      <pubDate>Wed, 12 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>https://dakerfp.com/post/opengl-lesson-02-drawing-with-opengl/</guid>
      <description>OpenGL is a primarily an C API, for drawing graphics. Implementations and bindings exists for several languages such as Java, Python, Ruby and Objective C. OpenGL became the standard drawing API supported by most modern device with graphics, independent from vendor, operational system, or if it is desktop or embedded. Of course the platform matters, but we can split the platform dependent code from pure OpenGL.
OpenGL became a standard mainly due to its rendering pipeline, which is trivially parallelized.</description>
    </item>
    
    <item>
      <title>Optimizing Functions with Python Caching Decorators</title>
      <link>https://dakerfp.com/post/optimizing-functions-with-python-caching-decorators/</link>
      <pubDate>Sat, 11 Jun 2011 00:00:00 +0000</pubDate>
      
      <guid>https://dakerfp.com/post/optimizing-functions-with-python-caching-decorators/</guid>
      <description>On these last months I&amp;rsquo;ve been solving some problems (such as some HMMs algorithms) which the best solutions involves some kind of dynamic programming. Some of them are quite simple to implement, but their recursive formulation are far more intuitive. The problem is that even in functional languages, the recursive functions aren&amp;rsquo;t well handled unless you some mechanism like tail call, which aren&amp;rsquo;t intuitive as we would like to. The simplest example that comes in my mind is the fibonacci function which is usually defined as:</description>
    </item>
    
  </channel>
</rss>