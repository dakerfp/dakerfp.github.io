<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Decorators on Daker Pinheiro</title>
    <link>https://dakerfp.com/tags/decorators/</link>
    <description>Recent content in Decorators on Daker Pinheiro</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>â’¸ 2017 Daker Fernandes Pinheiro</copyright>
    <lastBuildDate>Sat, 11 Jun 2011 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://dakerfp.com/tags/decorators/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Optimizing Functions with Python Caching Decorators</title>
      <link>https://dakerfp.com/post/optimizing-functions-with-python-caching-decorators/</link>
      <pubDate>Sat, 11 Jun 2011 00:00:00 +0000</pubDate>
      
      <guid>https://dakerfp.com/post/optimizing-functions-with-python-caching-decorators/</guid>
      <description>On these last months I&amp;rsquo;ve been solving some problems (such as some HMMs algorithms) which the best solutions involves some kind of dynamic programming. Some of them are quite simple to implement, but their recursive formulation are far more intuitive. The problem is that even in functional languages, the recursive functions aren&amp;rsquo;t well handled unless you some mechanism like tail call, which aren&amp;rsquo;t intuitive as we would like to. The simplest example that comes in my mind is the fibonacci function which is usually defined as:</description>
    </item>
    
  </channel>
</rss>